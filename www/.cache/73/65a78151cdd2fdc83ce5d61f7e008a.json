{"id":"../../spinal-env-viewer-task-service/build/index.js","dependencies":[{"name":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-browser-building-information/package.json","includedInParent":true,"mtime":1570182785170},{"name":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-task-service/package.json","includedInParent":true,"mtime":1569938308440},{"name":"spinal-env-viewer-graph-service","loc":{"line":7,"column":43},"parent":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-task-service/build/index.js","resolved":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-graph-service/dist/index.js"},{"name":"spinal-env-viewer-room-manager/js/service","loc":{"line":9,"column":23},"parent":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-task-service/build/index.js","resolved":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-room-manager/js/service.js"},{"name":"./models/visit.model.js","loc":{"line":11,"column":26},"parent":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-task-service/build/index.js","resolved":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-task-service/build/models/visit.model.js"},{"name":"./models/event.model.js","loc":{"line":15,"column":26},"parent":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-task-service/build/index.js","resolved":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-task-service/build/models/event.model.js"},{"name":"./models/task.model.js","loc":{"line":19,"column":25},"parent":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-task-service/build/index.js","resolved":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-task-service/build/models/task.model.js"},{"name":"spinal-core-connectorjs_type","loc":{"line":23,"column":42},"parent":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-task-service/build/index.js","resolved":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-core-connectorjs_type/dist/SpinalModel.js"},{"name":"moment","loc":{"line":25,"column":22},"parent":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/spinal-env-viewer-task-service/build/index.js","resolved":"/home/spinalcom/Documents/spinalcom/spinalcom/spinalcom_flo_attributs_tabs/node_modules/moment/moment.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _spinalEnvViewerGraphService = require(\"spinal-env-viewer-graph-service\");\n\nvar _service = require(\"spinal-env-viewer-room-manager/js/service\");\n\nvar _visitModel = require(\"./models/visit.model.js\");\n\nvar _visitModel2 = _interopRequireDefault(_visitModel);\n\nvar _eventModel = require(\"./models/event.model.js\");\n\nvar _eventModel2 = _interopRequireDefault(_eventModel);\n\nvar _taskModel = require(\"./models/task.model.js\");\n\nvar _taskModel2 = _interopRequireDefault(_taskModel);\n\nvar _spinalCoreConnectorjs_type = require(\"spinal-core-connectorjs_type\");\n\nvar _moment = require(\"moment\");\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nclass SpinalVisitService {\n  constructor() {\n    this.VISIT_CONTEXT_NAME = \".visit_context\";\n    this.CONTEXT_TYPE = \"visit_context\";\n\n    this.VISIT_TYPE = \"visit\";\n\n    this.MAINTENANCE_VISIT = \"MAINTENANCE_VISIT\";\n    this.REGULATORY_VISIT = \"REGULATORY_VISIT\";\n    this.SECURITY_VISIT = \"SECURITY_VISIT\";\n    this.DIAGNOSTIC_VISIT = \"DIAGNOSTIC_VISIT\";\n\n    this.EVENT_STATES = Object.freeze({\n      declared: {\n        name: \"déclaré\",\n        type: \"declared\"\n      },\n      processing: {\n        name: \"encours\",\n        type: \"processing\"\n      },\n      done: {\n        name: \"éffectué\",\n        type: \"done\"\n      }\n    });\n\n    this.VISITS = Object.freeze([{\n      type: this.MAINTENANCE_VISIT,\n      name: \"Visite de maintenance\"\n    }, {\n      type: this.REGULATORY_VISIT,\n      name: \"Visite reglementaire\"\n    }, {\n      type: this.SECURITY_VISIT,\n      name: \"Visite de securite\"\n    }, {\n      type: this.DIAGNOSTIC_VISIT,\n      name: \"Visite de diagnostic\"\n    }]);\n\n    this.MAINTENANCE_VISIT_EVENT_STATE_RELATION = \"maintenanceVisithasEventState\";\n\n    this.REGULATORY_VISIT_EVENT_STATE_RELATION = \"regulatoryVisithasEventState\";\n\n    this.SECURITY_VISIT_EVENT_STATE_RELATION = \"securityVisithasEventState\";\n\n    this.DIAGNOSTIC_VISIT_EVENT_STATE_RELATION = \"diagnosticVisithasEventState\";\n\n    this.GROUP_TO_TASK = \"hasVisit\";\n\n    this.VISIT_TO_EVENT_RELATION = \"visitHasEvent\";\n\n    this.VISIT_TYPE_TO_GROUP_RELATION = \"visitHasGroup\";\n    this.EVENT_STATE_TO_EVENT_RELATION = \"hasEvent\";\n    this.EVENT_TO_TASK_RELATION = \"hasTask\";\n\n    this.TASK_TO_COMMENTS_RELATION = \"hasComment\";\n  }\n\n  getAllVisits() {\n    return this.VISITS;\n  }\n\n  addVisitOnGroup(groupId, visitName, periodicityNumber, periodicityMesure, visitType, interventionNumber, interventionMesure, description) {\n    return _spinalEnvViewerGraphService.SpinalGraphService.getChildren(groupId, [this.GROUP_TO_TASK]).then(children => {\n      let argNodeId;\n      if (children.length === 0) {\n        argNodeId = _spinalEnvViewerGraphService.SpinalGraphService.createNode({\n          name: \"maintenance\"\n        });\n\n        _spinalEnvViewerGraphService.SpinalGraphService.addChild(groupId, argNodeId, this.GROUP_TO_TASK, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE);\n      }\n\n      let node = typeof argNodeId !== \"undefined\" ? _spinalEnvViewerGraphService.SpinalGraphService.getInfo(argNodeId) : children[0];\n\n      return this.getPtrValue(node, visitType).then(lst => {\n        let task = new _visitModel2.default(visitName, periodicityNumber, periodicityMesure, visitType, interventionNumber, interventionMesure, description);\n\n        let nodeId = _spinalEnvViewerGraphService.SpinalGraphService.createNode({\n          groupId: groupId,\n          name: visitName,\n          periodicity: {\n            number: task.periodicity.number.get(),\n            mesure: task.periodicity.mesure\n          },\n          intervention: {\n            number: task.intervention.number.get(),\n            mesure: task.intervention.mesure\n          },\n          visitType: visitType,\n          description: description\n        }, task);\n\n        let realNode = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(nodeId);\n\n        lst.push(realNode);\n\n        return realNode.info;\n      });\n    });\n  }\n\n  // deleteVisit(visitId, removeRelatedEvent) {\n  //   return this.removeVisitEvents(visitId, removeRelatedEvent).then((\n  //     info) => {\n\n  //     if (info) {\n  //       let groupId = info.groupId.get();\n  //       let visitContextType = info.visitType.get();\n\n  //       return this.getGroupVisits(groupId, visitContextType).then(\n  //         res => {\n  //           for (let index = 0; index < res.length; index++) {\n  //             const resVisitId = res[index].info.id.get();\n  //             if (resVisitId == visitId) {\n  //               res.remove(res[index]);\n  //               return true;\n  //             }\n  //           }\n  //           return false;\n  //         })\n  //     } else {\n  //       return false;\n  //     }\n\n  //   })\n  // }\n\n  deleteVisit(visitId, removeVisit, removeRelatedEvent, beginDate, endDate) {\n\n    if (removeRelatedEvent) {\n      this.removeVisitEvents(visitId, beginDate, endDate).then(el => {\n        if (removeVisit) {\n          return this.removeVisit(visitId);\n        }\n        return el;\n      });\n    } else if (removeVisit) {\n      return this.removeVisit(visitId);\n    }\n  }\n\n  removeVisitEvents(visitId, beginDate, endDate) {\n    // if (removeRelatedEvent) {\n    //   return SpinalGraphService.getChildren(visitId, [this\n    //     .VISIT_TO_EVENT_RELATION\n    //   ]).then((children) => {\n    //     let childrenPromise = children.map(el => {\n    //       return SpinalGraphService.removeFromGraph(el.id.get());\n    //     })\n\n    //     return Promise.all(childrenPromise).then(() => {\n    //       return SpinalGraphService.getInfo(visitId);\n    //     });\n\n    //   })\n    // } else {\n    //   return Promise.resolve(SpinalGraphService.getInfo(visitId));\n    // }\n\n    return this.getEventsBetweenTwoDate(visitId, beginDate, endDate).then(events => {\n      events.forEach(el => {\n        _spinalEnvViewerGraphService.SpinalGraphService.removeFromGraph(el.id);\n      });\n\n      return true;\n    });\n  }\n\n  getEventsBetweenTwoDate(visitId, beginDate, endDate) {\n\n    return _spinalEnvViewerGraphService.SpinalGraphService.getChildren(visitId, [this.VISIT_TO_EVENT_RELATION]).then(children => {\n\n      children = children.map(el => el.get());\n\n      return children.filter(el => {\n        return el.date >= beginDate && el.date <= endDate;\n      });\n    });\n  }\n\n  removeVisit(visitId) {\n    let info = _spinalEnvViewerGraphService.SpinalGraphService.getInfo(visitId);\n    if (info) {\n      let groupId = info.groupId.get();\n      let visitContextType = info.visitType.get();\n\n      return this.getGroupVisits(groupId, visitContextType).then(res => {\n        for (let index = 0; index < res.length; index++) {\n          const resVisitId = res[index].info.id.get();\n          if (resVisitId == visitId) {\n            res.remove(res[index]);\n            return true;\n          }\n        }\n        return false;\n      });\n    } else {\n      return Promise.resolve(false);\n    }\n  }\n\n  editVisit(visitId, newValuesObj) {\n    if (typeof newValuesObj !== \"object\") {\n      return false;\n    }\n\n    let visitNode = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(visitId);\n\n    if (typeof visitNode !== \"undefined\") {\n      for (const key in newValuesObj) {\n        const value = newValuesObj[key];\n\n        if (typeof value === \"string\" && typeof visitNode.info[key] !== \"undefined\") {\n\n          visitNode.info[key].set(value);\n        } else if (typeof value === \"object\" && typeof visitNode.info[key] !== \"undefined\") {\n\n          for (const key2 in value) {\n            const value2 = value[key2];\n\n            if (typeof visitNode.info[key][key2] !== \"undefined\") {\n\n              if (key === \"intervention\" && key2 === \"mesure\") {\n\n                if (typeof value2 !== \"undefined\") {\n\n                  visitNode.info[key][key2].set(new Choice(value2, [\"minute(s)\", \"day(s)\", \"week(s)\", \"month(s)\", \"year(s)\"]));\n                } else {\n                  visitNode.info[key][key2].set(NaN);\n                }\n              } else if (key === \"periodicity\" && key2 === \"mesure\") {\n\n                visitNode.info[key][key2].set(new Choice(value2, [\"day(s)\", \"week(s)\", \"month(s)\", \"year(s)\"]));\n              } else {\n                typeof value2 !== \"undefined\" ? visitNode.info[key][key2].set(value2) : visitNode.info[key][key2].set(NaN);\n              }\n            }\n          }\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  getPtrValue(node, ptrName) {\n    let realNode = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(node.id.get());\n\n    return new Promise(resolve => {\n      if (!realNode.info[ptrName]) {\n        realNode.info.add_attr(ptrName, {\n          tasks: new _spinalCoreConnectorjs_type.Ptr(new _spinalCoreConnectorjs_type.Lst())\n        });\n      }\n\n      realNode.info[ptrName].tasks.load(value => {\n        return resolve(value);\n      });\n    });\n  }\n\n  getGroupVisits(groupId, visityType) {\n    return _spinalEnvViewerGraphService.SpinalGraphService.getChildren(groupId, [this.GROUP_TO_TASK]).then(res => {\n      let nodeId;\n      if (res.length === 0) {\n        nodeId = _spinalEnvViewerGraphService.SpinalGraphService.createNode({\n          name: \"maintenance\"\n        });\n\n        _spinalEnvViewerGraphService.SpinalGraphService.addChild(groupId, nodeId, this.GROUP_TO_TASK, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE);\n      }\n\n      let node = typeof nodeId !== \"undefined\" ? _spinalEnvViewerGraphService.SpinalGraphService.getInfo(nodeId) : res[0];\n\n      return this.getPtrValue(node, visityType);\n    });\n  }\n\n  generateEvent(visitType, groupId, beginDate, endDate, eventsData) {\n    return this.createVisitContext(visitType).then(el => {\n      return this.linkGroupToVistContext(el.id.get(), groupId).then(res => {\n        if (res) {\n          this.getEventStateNode(el.id.get(), groupId, this.EVENT_STATES.declared.type).then(stateNode => {\n            let id = stateNode.id.get();\n\n            eventsData.forEach(eventInfo => {\n              let eventsDate = this._getDate(beginDate, endDate, eventInfo.periodNumber, eventInfo.periodMesure);\n\n              eventsDate.forEach(date => {\n                this.addEvent(el.id.get(), groupId, id, eventInfo, `${eventInfo.name}`, new Date(date).getTime());\n              });\n            });\n          });\n        }\n      });\n    }).catch(err => {\n      console.log(err);\n      return Promise.resolve(err);\n    });\n  }\n\n  addEvent(visitTypeContextId, groupId, stateId, visitInfo, name, date) {\n    let state = _spinalEnvViewerGraphService.SpinalGraphService.getInfo(stateId).state.get();\n\n    let event = new _eventModel2.default(name, date, state, groupId);\n\n    let eventNodeId = _spinalEnvViewerGraphService.SpinalGraphService.createNode({\n      name: name,\n      date: date,\n      stateId: stateId,\n      state: state,\n      groupId: groupId,\n      visitId: visitInfo.id\n    }, event);\n\n    return _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(stateId, eventNodeId, visitTypeContextId, this.EVENT_STATE_TO_EVENT_RELATION, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE).then(el => {\n      if (el) return eventNodeId;\n    }).then(eventId => {\n      if (typeof eventId !== \"undefined\") {\n        return _spinalEnvViewerGraphService.SpinalGraphService.getChildren(groupId, [_service.EQUIPMENTS_TO_ELEMENT_RELATION]).then(children => {\n          children.map(child => {\n            let name = `${child.name.get()}`;\n            let task = new _taskModel2.default(name, child.dbid.get(), child.bimFileId.get(), visitInfo.name, 0);\n\n            let taskId = _spinalEnvViewerGraphService.SpinalGraphService.createNode({\n              name: name,\n              type: \"task\",\n              dbId: child.dbid.get(),\n              bimFileId: child.bimFileId.get(),\n              visitId: visitInfo.id,\n              eventId: eventId,\n              groupId: groupId,\n              done: false\n            }, task);\n\n            return Promise.all([_spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(eventId, taskId, visitTypeContextId, this.EVENT_TO_TASK_RELATION, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE), _spinalEnvViewerGraphService.SpinalGraphService.addChild(visitInfo.id, eventId, this.VISIT_TO_EVENT_RELATION, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE)]);\n          });\n        });\n      }\n    });\n  }\n\n  createVisitContext(visitType) {\n    let visit = this.VISITS.find(el => {\n      return el.type === visitType;\n    });\n\n    if (typeof visit !== \"undefined\") {\n      const contextName = `${visit.name}`;\n\n      let context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(contextName);\n      if (typeof context !== \"undefined\") return Promise.resolve(context.info);\n\n      return _spinalEnvViewerGraphService.SpinalGraphService.addContext(contextName, visitType, new _spinalCoreConnectorjs_type.Model({\n        name: this.VISIT_CONTEXT_NAME\n      })).then(contextCreated => {\n        return contextCreated.info;\n      });\n    } else {\n      return Promise.reject(\"visitNotFound\");\n    }\n  }\n\n  linkGroupToVistContext(visitContextId, groupId) {\n    var _this = this;\n\n    return _spinalEnvViewerGraphService.SpinalGraphService.getChildren(visitContextId, [this.VISIT_TYPE_TO_GROUP_RELATION]).then(children => {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i].id.get();\n        if (child === groupId) return true;\n      }\n    }).then(el => {\n      if (typeof el === \"undefined\") {\n        return _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(visitContextId, groupId, visitContextId, this.VISIT_TYPE_TO_GROUP_RELATION, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE).then((() => {\n          var _ref = _asyncToGenerator(function* (res) {\n            if (res) {\n              yield _this.getEventStateNode(visitContextId, groupId, _this.EVENT_STATES.processing.type);\n              yield _this.getEventStateNode(visitContextId, groupId, _this.EVENT_STATES.done.type);\n            }\n\n            return res;\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        })());\n      } else {\n        return el;\n      }\n    });\n  }\n\n  getEventStateNode(visitContextId, groupId, eventSate) {\n    let event = this._eventSateIsValid(eventSate);\n\n    if (typeof event === \"undefined\") return;\n\n    let contextType = _spinalEnvViewerGraphService.SpinalGraphService.getInfo(visitContextId).type.get();\n    let relationName;\n\n    switch (contextType) {\n      case this.MAINTENANCE_VISIT:\n        relationName = this.MAINTENANCE_VISIT_EVENT_STATE_RELATION;\n        break;\n      case this.SECURITY_VISIT:\n        relationName = this.SECURITY_VISIT_EVENT_STATE_RELATION;\n        break;\n      case this.DIAGNOSTIC_VISIT:\n        relationName = this.DIAGNOSTIC_VISIT_EVENT_STATE_RELATION;\n        break;\n      case this.REGULATORY_VISIT:\n        relationName = this.REGULATORY_VISIT_EVENT_STATE_RELATION;\n        break;\n    }\n\n    return _spinalEnvViewerGraphService.SpinalGraphService.getChildren(groupId, [relationName]).then(children => {\n      for (let i = 0; i < children.length; i++) {\n        const name = children[i].name.get();\n        const type = children[i].state.get();\n\n        if (name === eventSate || type === eventSate) {\n          return children[i];\n        }\n      }\n    }).then(el => {\n      if (typeof el === \"undefined\") {\n        let argNodeId = _spinalEnvViewerGraphService.SpinalGraphService.createNode({\n          name: event.name,\n          state: event.type,\n          groupId: groupId,\n          type: \"EventState\"\n        });\n\n        return _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(groupId, argNodeId, visitContextId, relationName, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE).then(res => {\n          if (res) return _spinalEnvViewerGraphService.SpinalGraphService.getInfo(argNodeId);\n        });\n      } else {\n        return el;\n      }\n    });\n  }\n\n  validateTask(contextId, groupId, eventId, taskId) {\n    let taskNode = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(taskId);\n    taskNode.info.done.set(!taskNode.info.done.get());\n\n    let currentStateId = _spinalEnvViewerGraphService.SpinalGraphService.getInfo(eventId).stateId.get();\n\n    return this._getState(contextId, groupId, eventId).then(nextState => {\n\n      let nextStateId = nextState.id.get();\n\n      if (nextStateId === currentStateId) return true;\n\n      return this._switchEventState(eventId, currentStateId, nextStateId, contextId);\n    });\n  }\n\n  ////////////////////////////////////////////////////////////////////////\n  //                            PRIVATES                                //\n  ////////////////////////////////////////////////////////////////////////\n\n  _getDate(beginDate, endDate, periodNumber, periodMesure) {\n    let mesure = [\"days\", \"weeks\", \"months\", \"years\"][periodMesure];\n\n    let eventsDate = [];\n\n    let date = (0, _moment2.default)(beginDate);\n    let end = (0, _moment2.default)(endDate);\n\n    while (end.diff(date) >= 0) {\n      eventsDate.push(date.toDate());\n\n      date = date.add(periodNumber, mesure);\n    }\n\n    return eventsDate;\n  }\n\n  _formatDate(argDate) {\n    let date = new Date(argDate);\n\n    return `${(() => {\n      let d = date.getDate();\n      return d.toString().length > 1 ? d : '0' + d;\n    })()}/${(() => {\n\n      let d = date.getMonth() + 1;\n      return d.toString().length > 1 ? d : '0' + d;\n    })()}/${date.getFullYear()}`;\n  }\n\n  _eventSateIsValid(eventState) {\n    for (const key in this.EVENT_STATES) {\n      if (this.EVENT_STATES[key].name === eventState || this.EVENT_STATES[key].type === eventState) {\n        return this.EVENT_STATES[key];\n      }\n    }\n\n    return undefined;\n  }\n\n  _getState(contextId, groupId, eventId) {\n\n    return this.getEventTasks(eventId).then(tasks => {\n      let tasksValidated = tasks.filter(el => el.done);\n      let stateObj;\n\n      if (tasksValidated.length === 0) {\n        stateObj = this.EVENT_STATES.declared;\n      } else if (tasksValidated.length === tasks.length) {\n        stateObj = this.EVENT_STATES.done;\n      } else {\n        stateObj = this.EVENT_STATES.processing;\n      }\n\n      return this.getEventStateNode(contextId, groupId, stateObj.type);\n    });\n  }\n\n  _switchEventState(eventId, fromStateId, toStateId, contextId) {\n\n    return _spinalEnvViewerGraphService.SpinalGraphService.removeChild(fromStateId, eventId, this.EVENT_STATE_TO_EVENT_RELATION, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE).then(removed => {\n      if (removed) {\n        return _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(toStateId, eventId, contextId, this.EVENT_STATE_TO_EVENT_RELATION, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE).then(res => {\n          if (typeof res !== \"undefined\") {\n            let EventNode = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(eventId);\n            let newState = _spinalEnvViewerGraphService.SpinalGraphService.getInfo(toStateId).state.get();\n\n            EventNode.info.state.set(newState);\n            EventNode.info.stateId.set(toStateId);\n          }\n        });\n      } else {\n        return Promise.resolve(false);\n      }\n    });\n  }\n\n  ////////////////////////////////////////////////////////////////////////\n  //                        GET INFORMATION                             //\n  ////////////////////////////////////////////////////////////////////////\n\n  getVisitGroups(visitType) {\n    let contexts = _spinalEnvViewerGraphService.SpinalGraphService.getContextWithType(visitType);\n    if (contexts.length === 0) return [];\n\n    let contextId = contexts[0].info.id.get();\n\n    return _spinalEnvViewerGraphService.SpinalGraphService.getChildren(contextId, this.VISIT_TYPE_TO_GROUP_RELATION).then(res => {\n      return res.map(el => el.get());\n    });\n  }\n\n  getGroupEventStates(contextId, groupId) {\n    let promises = [];\n\n    for (const key in this.EVENT_STATES) {\n      promises.push(this.getEventStateNode(contextId, groupId, this.EVENT_STATES[key].type));\n    }\n\n    return Promise.all(promises);\n  }\n\n  getGroupEvents(groupId, VISIT_TYPES = [this.MAINTENANCE_VISIT, this.REGULATORY_VISIT, this.SECURITY_VISIT, this.DIAGNOSTIC_VISIT]) {\n    var _this2 = this;\n\n    if (!Array.isArray(VISIT_TYPES)) VISIT_TYPES = [VISIT_TYPES];\n\n    return VISIT_TYPES.map(visitType => {\n      let visit = this.VISITS.find(el => {\n        return el.type === visitType;\n      });\n\n      let context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(visit.name);\n\n      if (typeof context !== \"undefined\") {\n        let contextId = context.info.id.get();\n\n        return this.getGroupEventStates(contextId, groupId).then(values => {\n          let prom = values.map((() => {\n            var _ref2 = _asyncToGenerator(function* (eventType) {\n              let res = eventType.get();\n\n              res[\"visit_type\"] = visitType;\n\n              let events = yield _spinalEnvViewerGraphService.SpinalGraphService.getChildren(res.id, [_this2.EVENT_STATE_TO_EVENT_RELATION]);\n\n              res[\"events\"] = events.map(function (el) {\n                return el.get();\n              });\n\n              return res;\n            });\n\n            return function (_x2) {\n              return _ref2.apply(this, arguments);\n            };\n          })());\n\n          return Promise.all(prom).then(allEvents => {\n            let values = {};\n\n            allEvents.forEach(val => {\n              values[val.state] = val.events;\n            });\n\n            return {\n              [visitType]: values\n            };\n          });\n        });\n      }\n    });\n  }\n\n  getEventTasks(eventId) {\n    return _spinalEnvViewerGraphService.SpinalGraphService.getChildren(eventId, [this.EVENT_TO_TASK_RELATION]).then(children => {\n      return children.map(el => el.get());\n    });\n  }\n\n  ////////////////////////////////////////////////////////////////////////\n  //                        Comment Manager                             //\n  ////////////////////////////////////////////////////////////////////////\n\n  addComment(taskId, userId, message) {\n    if (message && message.trim().length > 0 && userId) {\n      let commentNodeId = _spinalEnvViewerGraphService.SpinalGraphService.createNode({\n        userId: userId,\n        message: message,\n        taskId: taskId,\n        date: Date.now()\n      });\n\n      if (commentNodeId) {\n        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(taskId, commentNodeId, this.TASK_TO_COMMENTS_RELATION, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE);\n      }\n    } else {\n      return Promise.reject(false);\n    }\n  }\n\n  getTasksComments(taskId) {\n    return _spinalEnvViewerGraphService.SpinalGraphService.getChildren(taskId, [this.TASK_TO_COMMENTS_RELATION]).then(children => {\n      return children.map(el => el.get());\n    });\n  }\n\n}\n\nlet spinalVisitService = new SpinalVisitService();\n\nexports.default = spinalVisitService;\n"},"sourceMaps":{"js":{"version":3,"sources":["../src/index.js"],"names":["SpinalVisitService","constructor","VISIT_CONTEXT_NAME","CONTEXT_TYPE","VISIT_TYPE","MAINTENANCE_VISIT","REGULATORY_VISIT","SECURITY_VISIT","DIAGNOSTIC_VISIT","EVENT_STATES","Object","freeze","declared","name","type","processing","done","VISITS","MAINTENANCE_VISIT_EVENT_STATE_RELATION","REGULATORY_VISIT_EVENT_STATE_RELATION","SECURITY_VISIT_EVENT_STATE_RELATION","DIAGNOSTIC_VISIT_EVENT_STATE_RELATION","GROUP_TO_TASK","VISIT_TO_EVENT_RELATION","VISIT_TYPE_TO_GROUP_RELATION","EVENT_STATE_TO_EVENT_RELATION","EVENT_TO_TASK_RELATION","TASK_TO_COMMENTS_RELATION","getAllVisits","addVisitOnGroup","groupId","visitName","periodicityNumber","periodicityMesure","visitType","interventionNumber","interventionMesure","description","SpinalGraphService","getChildren","then","children","argNodeId","length","createNode","addChild","SPINAL_RELATION_PTR_LST_TYPE","node","getInfo","getPtrValue","lst","task","VisitModel","nodeId","periodicity","number","get","mesure","intervention","realNode","getRealNode","push","info","deleteVisit","visitId","removeVisit","removeRelatedEvent","beginDate","endDate","removeVisitEvents","el","getEventsBetweenTwoDate","events","forEach","removeFromGraph","id","map","filter","date","visitContextType","getGroupVisits","res","index","resVisitId","remove","Promise","resolve","editVisit","newValuesObj","visitNode","key","value","set","key2","value2","Choice","NaN","ptrName","add_attr","tasks","Ptr","Lst","load","visityType","generateEvent","eventsData","createVisitContext","linkGroupToVistContext","getEventStateNode","stateNode","eventInfo","eventsDate","_getDate","periodNumber","periodMesure","addEvent","Date","getTime","catch","err","console","log","visitTypeContextId","stateId","visitInfo","state","event","EventModel","eventNodeId","addChildInContext","eventId","EQUIPMENTS_TO_ELEMENT_RELATION","child","TaskModel","dbid","bimFileId","taskId","dbId","all","visit","find","contextName","context","getContext","addContext","Model","contextCreated","reject","visitContextId","i","eventSate","_eventSateIsValid","contextType","relationName","validateTask","contextId","taskNode","currentStateId","_getState","nextState","nextStateId","_switchEventState","end","diff","toDate","add","_formatDate","argDate","d","getDate","toString","getMonth","getFullYear","eventState","undefined","getEventTasks","tasksValidated","stateObj","fromStateId","toStateId","removeChild","removed","EventNode","newState","getVisitGroups","contexts","getContextWithType","getGroupEventStates","promises","getGroupEvents","VISIT_TYPES","Array","isArray","values","prom","eventType","allEvents","val","addComment","userId","message","trim","commentNodeId","now","getTasksComments","spinalVisitService"],"mappings":"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","file":"index.js","sourcesContent":["import {\n  SPINAL_RELATION_PTR_LST_TYPE,\n  SpinalGraphService\n} from \"spinal-env-viewer-graph-service\";\n\nimport {\n  EQUIPMENTS_TO_ELEMENT_RELATION\n} from \"spinal-env-viewer-room-manager/js/service\";\n\nimport VisitModel from \"./models/visit.model.js\";\nimport EventModel from \"./models/event.model.js\";\nimport TaskModel from \"./models/task.model.js\";\n\nimport {\n  Ptr,\n  Lst,\n  Model\n} from \"spinal-core-connectorjs_type\";\n\nimport moment from \"moment\";\n\nclass SpinalVisitService {\n  constructor() {\n    this.VISIT_CONTEXT_NAME = \".visit_context\";\n    this.CONTEXT_TYPE = \"visit_context\";\n\n    this.VISIT_TYPE = \"visit\";\n\n    this.MAINTENANCE_VISIT = \"MAINTENANCE_VISIT\";\n    this.REGULATORY_VISIT = \"REGULATORY_VISIT\";\n    this.SECURITY_VISIT = \"SECURITY_VISIT\";\n    this.DIAGNOSTIC_VISIT = \"DIAGNOSTIC_VISIT\";\n\n    this.EVENT_STATES = Object.freeze({\n      declared: {\n        name: \"déclaré\",\n        type: \"declared\"\n      },\n      processing: {\n        name: \"encours\",\n        type: \"processing\"\n      },\n      done: {\n        name: \"éffectué\",\n        type: \"done\"\n      }\n    });\n\n    this.VISITS = Object.freeze([{\n      type: this.MAINTENANCE_VISIT,\n      name: \"Visite de maintenance\"\n    }, {\n      type: this.REGULATORY_VISIT,\n      name: \"Visite reglementaire\"\n    }, {\n      type: this.SECURITY_VISIT,\n      name: \"Visite de securite\"\n    }, {\n      type: this.DIAGNOSTIC_VISIT,\n      name: \"Visite de diagnostic\"\n    }]);\n\n\n    this.MAINTENANCE_VISIT_EVENT_STATE_RELATION =\n      \"maintenanceVisithasEventState\";\n\n    this.REGULATORY_VISIT_EVENT_STATE_RELATION =\n      \"regulatoryVisithasEventState\";\n\n    this.SECURITY_VISIT_EVENT_STATE_RELATION = \"securityVisithasEventState\";\n\n    this.DIAGNOSTIC_VISIT_EVENT_STATE_RELATION =\n      \"diagnosticVisithasEventState\";\n\n    this.GROUP_TO_TASK = \"hasVisit\";\n\n    this.VISIT_TO_EVENT_RELATION = \"visitHasEvent\";\n\n    this.VISIT_TYPE_TO_GROUP_RELATION = \"visitHasGroup\";\n    this.EVENT_STATE_TO_EVENT_RELATION = \"hasEvent\";\n    this.EVENT_TO_TASK_RELATION = \"hasTask\";\n\n    this.TASK_TO_COMMENTS_RELATION = \"hasComment\"\n  }\n\n  getAllVisits() {\n    return this.VISITS;\n  }\n\n  addVisitOnGroup(\n    groupId,\n    visitName,\n    periodicityNumber,\n    periodicityMesure,\n    visitType,\n    interventionNumber,\n    interventionMesure,\n    description\n  ) {\n    return SpinalGraphService.getChildren(groupId, [this.GROUP_TO_TASK]).then(\n      children => {\n        let argNodeId;\n        if (children.length === 0) {\n          argNodeId = SpinalGraphService.createNode({\n            name: \"maintenance\"\n          });\n\n          SpinalGraphService.addChild(\n            groupId,\n            argNodeId,\n            this.GROUP_TO_TASK,\n            SPINAL_RELATION_PTR_LST_TYPE\n          );\n        }\n\n        let node =\n          typeof argNodeId !== \"undefined\" ?\n          SpinalGraphService.getInfo(argNodeId) :\n          children[0];\n\n        return this.getPtrValue(node, visitType).then(lst => {\n          let task = new VisitModel(\n            visitName,\n            periodicityNumber,\n            periodicityMesure,\n            visitType,\n            interventionNumber,\n            interventionMesure,\n            description\n          );\n\n          let nodeId = SpinalGraphService.createNode({\n              groupId: groupId,\n              name: visitName,\n              periodicity: {\n                number: task.periodicity.number.get(),\n                mesure: task.periodicity.mesure\n              },\n              intervention: {\n                number: task.intervention.number.get(),\n                mesure: task.intervention.mesure\n              },\n              visitType: visitType,\n              description: description\n            },\n            task\n          );\n\n          let realNode = SpinalGraphService.getRealNode(nodeId);\n\n          lst.push(realNode);\n\n          return realNode.info;\n        });\n      }\n    );\n  }\n\n  // deleteVisit(visitId, removeRelatedEvent) {\n  //   return this.removeVisitEvents(visitId, removeRelatedEvent).then((\n  //     info) => {\n\n  //     if (info) {\n  //       let groupId = info.groupId.get();\n  //       let visitContextType = info.visitType.get();\n\n  //       return this.getGroupVisits(groupId, visitContextType).then(\n  //         res => {\n  //           for (let index = 0; index < res.length; index++) {\n  //             const resVisitId = res[index].info.id.get();\n  //             if (resVisitId == visitId) {\n  //               res.remove(res[index]);\n  //               return true;\n  //             }\n  //           }\n  //           return false;\n  //         })\n  //     } else {\n  //       return false;\n  //     }\n\n  //   })\n  // }\n\n  deleteVisit(visitId, removeVisit, removeRelatedEvent, beginDate, endDate) {\n\n    if (removeRelatedEvent) {\n      this.removeVisitEvents(visitId, beginDate, endDate).then(el => {\n        if (removeVisit) {\n          return this.removeVisit(visitId);\n        }\n        return el;\n      })\n    } else if (removeVisit) {\n      return this.removeVisit(visitId);\n    }\n\n  }\n\n  removeVisitEvents(visitId, beginDate, endDate) {\n    // if (removeRelatedEvent) {\n    //   return SpinalGraphService.getChildren(visitId, [this\n    //     .VISIT_TO_EVENT_RELATION\n    //   ]).then((children) => {\n    //     let childrenPromise = children.map(el => {\n    //       return SpinalGraphService.removeFromGraph(el.id.get());\n    //     })\n\n    //     return Promise.all(childrenPromise).then(() => {\n    //       return SpinalGraphService.getInfo(visitId);\n    //     });\n\n    //   })\n    // } else {\n    //   return Promise.resolve(SpinalGraphService.getInfo(visitId));\n    // }\n\n    return this.getEventsBetweenTwoDate(visitId, beginDate, endDate).then(\n      events => {\n        events.forEach(el => {\n          SpinalGraphService.removeFromGraph(el.id);\n        });\n\n        return true;\n\n      })\n\n  }\n\n\n  getEventsBetweenTwoDate(visitId, beginDate, endDate) {\n\n    return SpinalGraphService.getChildren(visitId, [this\n      .VISIT_TO_EVENT_RELATION\n    ]).then((children) => {\n\n      children = children.map(el => el.get());\n\n      return children.filter(el => {\n        return el.date >= beginDate && el.date <= endDate;\n      })\n\n    })\n\n  }\n\n  removeVisit(visitId) {\n    let info = SpinalGraphService.getInfo(visitId);\n    if (info) {\n      let groupId = info.groupId.get();\n      let visitContextType = info.visitType.get();\n\n      return this.getGroupVisits(groupId, visitContextType).then(\n        res => {\n          for (let index = 0; index < res.length; index++) {\n            const resVisitId = res[index].info.id.get();\n            if (resVisitId == visitId) {\n              res.remove(res[index]);\n              return true;\n            }\n          }\n          return false;\n        })\n    } else {\n      return Promise.resolve(false);\n    }\n  }\n\n  editVisit(visitId, newValuesObj) {\n    if (typeof newValuesObj !== \"object\") {\n      return false;\n    }\n\n    let visitNode = SpinalGraphService.getRealNode(visitId);\n\n    if (typeof visitNode !== \"undefined\") {\n      for (const key in newValuesObj) {\n        const value = newValuesObj[key];\n\n        if (typeof value === \"string\" && typeof visitNode.info[key] !==\n          \"undefined\") {\n\n          visitNode.info[key].set(value);\n\n        } else if (typeof value === \"object\" && typeof visitNode.info[key] !==\n          \"undefined\") {\n\n          for (const key2 in value) {\n            const value2 = value[key2];\n\n\n            if (typeof visitNode.info[key][key2] !== \"undefined\") {\n\n              if (key === \"intervention\" && key2 === \"mesure\") {\n\n                if (typeof value2 !== \"undefined\") {\n\n                  visitNode.info[key][key2].set(new Choice(\n                    value2, [\n                      \"minute(s)\", \"day(s)\",\n                      \"week(s)\", \"month(s)\",\n                      \"year(s)\"\n                    ]));\n                } else {\n                  visitNode.info[key][key2].set(NaN);\n                }\n\n              } else if (key === \"periodicity\" && key2 === \"mesure\") {\n\n                visitNode.info[key][key2].set(new Choice(value2, [\n                  \"day(s)\", \"week(s)\",\n                  \"month(s)\",\n                  \"year(s)\"\n                ]));\n              } else {\n                typeof value2 !== \"undefined\" ? visitNode.info[key][key2].set(\n                  value2) : visitNode.info[key][key2].set(NaN);\n              }\n\n\n            }\n\n          }\n        }\n\n\n      }\n\n      return true;\n\n    }\n\n    return false;\n\n  }\n\n  getPtrValue(node, ptrName) {\n    let realNode = SpinalGraphService.getRealNode(node.id.get());\n\n    return new Promise(resolve => {\n      if (!realNode.info[ptrName]) {\n        realNode.info.add_attr(ptrName, {\n          tasks: new Ptr(new Lst())\n        });\n      }\n\n      realNode.info[ptrName].tasks.load(value => {\n        return resolve(value);\n      });\n    });\n  }\n\n  getGroupVisits(groupId, visityType) {\n    return SpinalGraphService.getChildren(groupId, [this.GROUP_TO_TASK]).then(\n      res => {\n        let nodeId;\n        if (res.length === 0) {\n          nodeId = SpinalGraphService.createNode({\n            name: \"maintenance\"\n          });\n\n          SpinalGraphService.addChild(\n            groupId,\n            nodeId,\n            this.GROUP_TO_TASK,\n            SPINAL_RELATION_PTR_LST_TYPE\n          );\n        }\n\n        let node =\n          typeof nodeId !== \"undefined\" ?\n          SpinalGraphService.getInfo(nodeId) :\n          res[0];\n\n        return this.getPtrValue(node, visityType);\n      }\n    );\n  }\n\n  generateEvent(visitType, groupId, beginDate, endDate, eventsData) {\n    return this.createVisitContext(visitType)\n      .then(el => {\n        return this.linkGroupToVistContext(el.id.get(), groupId).then(\n          res => {\n            if (res) {\n              this.getEventStateNode(\n                el.id.get(),\n                groupId,\n                this.EVENT_STATES.declared.type\n              ).then(stateNode => {\n                let id = stateNode.id.get();\n\n                eventsData.forEach(eventInfo => {\n                  let eventsDate = this._getDate(\n                    beginDate,\n                    endDate,\n                    eventInfo.periodNumber,\n                    eventInfo.periodMesure\n                  );\n\n                  eventsDate.forEach(date => {\n                    this.addEvent(\n                      el.id.get(),\n                      groupId,\n                      id,\n                      eventInfo,\n                      `${eventInfo.name}`,\n                      new Date(date).getTime()\n                    );\n                  });\n                });\n              });\n            }\n          });\n      })\n      .catch(err => {\n        console.log(err);\n        return Promise.resolve(err);\n      });\n  }\n\n  addEvent(visitTypeContextId, groupId, stateId, visitInfo, name, date) {\n    let state = SpinalGraphService.getInfo(stateId).state.get();\n\n    let event = new EventModel(name, date, state, groupId);\n\n    let eventNodeId = SpinalGraphService.createNode({\n        name: name,\n        date: date,\n        stateId: stateId,\n        state: state,\n        groupId: groupId,\n        visitId: visitInfo.id\n      },\n      event\n    );\n\n    return SpinalGraphService.addChildInContext(\n        stateId,\n        eventNodeId,\n        visitTypeContextId,\n        this.EVENT_STATE_TO_EVENT_RELATION,\n        SPINAL_RELATION_PTR_LST_TYPE\n      )\n      .then(el => {\n        if (el) return eventNodeId;\n      })\n      .then(eventId => {\n        if (typeof eventId !== \"undefined\") {\n          return SpinalGraphService.getChildren(groupId, [\n            EQUIPMENTS_TO_ELEMENT_RELATION\n          ]).then(children => {\n            children.map(child => {\n              let name = `${child.name.get()}`;\n              let task = new TaskModel(\n                name,\n                child.dbid.get(),\n                child.bimFileId.get(),\n                visitInfo.name,\n                0\n              );\n\n              let taskId = SpinalGraphService.createNode({\n                  name: name,\n                  type: \"task\",\n                  dbId: child.dbid.get(),\n                  bimFileId: child.bimFileId.get(),\n                  visitId: visitInfo.id,\n                  eventId: eventId,\n                  groupId: groupId,\n                  done: false\n                },\n                task\n              );\n\n              return Promise.all([\n                SpinalGraphService.addChildInContext(\n                  eventId,\n                  taskId,\n                  visitTypeContextId,\n                  this.EVENT_TO_TASK_RELATION,\n                  SPINAL_RELATION_PTR_LST_TYPE\n                ),\n                SpinalGraphService.addChild(\n                  visitInfo.id,\n                  eventId,\n                  this.VISIT_TO_EVENT_RELATION,\n                  SPINAL_RELATION_PTR_LST_TYPE\n                )\n              ]);\n            });\n          });\n        }\n      });\n  }\n\n  createVisitContext(visitType) {\n    let visit = this.VISITS.find(el => {\n      return el.type === visitType;\n    });\n\n    if (typeof visit !== \"undefined\") {\n      const contextName = `${visit.name}`;\n\n      let context = SpinalGraphService.getContext(contextName);\n      if (typeof context !== \"undefined\") return Promise.resolve(context\n        .info);\n\n      return SpinalGraphService.addContext(\n        contextName,\n        visitType,\n        new Model({\n          name: this.VISIT_CONTEXT_NAME\n        })\n      ).then(contextCreated => {\n        return contextCreated.info;\n      });\n    } else {\n      return Promise.reject(\"visitNotFound\");\n    }\n  }\n\n  linkGroupToVistContext(visitContextId, groupId) {\n    return SpinalGraphService.getChildren(visitContextId, [\n        this.VISIT_TYPE_TO_GROUP_RELATION\n      ])\n      .then(children => {\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i].id.get();\n          if (child === groupId) return true;\n        }\n      })\n      .then(el => {\n        if (typeof el === \"undefined\") {\n          return SpinalGraphService.addChildInContext(\n            visitContextId,\n            groupId,\n            visitContextId,\n            this.VISIT_TYPE_TO_GROUP_RELATION,\n            SPINAL_RELATION_PTR_LST_TYPE\n          ).then(async res => {\n            if (res) {\n              await this.getEventStateNode(\n                visitContextId,\n                groupId,\n                this.EVENT_STATES.processing.type\n              );\n              await this.getEventStateNode(\n                visitContextId,\n                groupId,\n                this.EVENT_STATES.done.type\n              );\n            }\n\n            return res;\n          });\n        } else {\n          return el;\n        }\n      });\n  }\n\n  getEventStateNode(visitContextId, groupId, eventSate) {\n    let event = this._eventSateIsValid(eventSate);\n\n    if (typeof event === \"undefined\") return;\n\n    let contextType = SpinalGraphService.getInfo(visitContextId).type.get();\n    let relationName;\n\n    switch (contextType) {\n      case this.MAINTENANCE_VISIT:\n        relationName = this.MAINTENANCE_VISIT_EVENT_STATE_RELATION;\n        break;\n      case this.SECURITY_VISIT:\n        relationName = this.SECURITY_VISIT_EVENT_STATE_RELATION;\n        break;\n      case this.DIAGNOSTIC_VISIT:\n        relationName = this.DIAGNOSTIC_VISIT_EVENT_STATE_RELATION;\n        break;\n      case this.REGULATORY_VISIT:\n        relationName = this.REGULATORY_VISIT_EVENT_STATE_RELATION;\n        break;\n    }\n\n    return SpinalGraphService.getChildren(groupId, [relationName])\n      .then(children => {\n        for (let i = 0; i < children.length; i++) {\n          const name = children[i].name.get();\n          const type = children[i].state.get();\n\n          if (name === eventSate || type === eventSate) {\n            return children[i];\n          }\n        }\n      })\n      .then(el => {\n        if (typeof el === \"undefined\") {\n          let argNodeId = SpinalGraphService.createNode({\n            name: event.name,\n            state: event.type,\n            groupId: groupId,\n            type: \"EventState\"\n          });\n\n          return SpinalGraphService.addChildInContext(\n            groupId,\n            argNodeId,\n            visitContextId,\n            relationName,\n            SPINAL_RELATION_PTR_LST_TYPE\n          ).then(res => {\n            if (res) return SpinalGraphService.getInfo(argNodeId);\n          });\n        } else {\n          return el;\n        }\n      });\n  }\n\n  validateTask(contextId, groupId, eventId, taskId) {\n    let taskNode = SpinalGraphService.getRealNode(taskId);\n    taskNode.info.done.set(!taskNode.info.done.get());\n\n    let currentStateId = SpinalGraphService.getInfo(eventId).stateId.get();\n\n    return this._getState(contextId, groupId, eventId).then(nextState => {\n\n      let nextStateId = nextState.id.get();\n\n      if (nextStateId === currentStateId) return true;\n\n      return this._switchEventState(eventId, currentStateId, nextStateId,\n        contextId);\n\n    });\n\n  }\n\n\n\n  ////////////////////////////////////////////////////////////////////////\n  //                            PRIVATES                                //\n  ////////////////////////////////////////////////////////////////////////\n\n  _getDate(beginDate, endDate, periodNumber, periodMesure) {\n    let mesure = [\"days\", \"weeks\", \"months\", \"years\"][periodMesure];\n\n    let eventsDate = [];\n\n    let date = moment(beginDate);\n    let end = moment(endDate);\n\n    while (end.diff(date) >= 0) {\n      eventsDate.push(date.toDate());\n\n      date = date.add(periodNumber, mesure);\n    }\n\n    return eventsDate;\n  }\n\n  _formatDate(argDate) {\n    let date = new Date(argDate);\n\n    return `${(() => {\n      let d = date.getDate();\n      return d.toString().length > 1 ? d : '0' + d;\n    })()}/${(() => {\n\n      let d = date.getMonth() + 1;\n      return d.toString().length > 1 ? d : '0' + d;\n\n    })()}/${date.getFullYear()}`;\n  }\n\n  _eventSateIsValid(eventState) {\n    for (const key in this.EVENT_STATES) {\n      if (\n        this.EVENT_STATES[key].name === eventState ||\n        this.EVENT_STATES[key].type === eventState\n      ) {\n        return this.EVENT_STATES[key];\n      }\n    }\n\n    return undefined;\n  }\n\n  _getState(contextId, groupId, eventId) {\n\n    return this.getEventTasks(eventId).then(tasks => {\n      let tasksValidated = tasks.filter(el => el.done);\n      let stateObj;\n\n      if (tasksValidated.length === 0) {\n        stateObj = this.EVENT_STATES.declared;\n      } else if (tasksValidated.length === tasks.length) {\n        stateObj = this.EVENT_STATES.done;\n      } else {\n        stateObj = this.EVENT_STATES.processing;\n      }\n\n      return this.getEventStateNode(contextId, groupId, stateObj.type);\n\n    })\n\n  }\n\n  _switchEventState(eventId, fromStateId, toStateId, contextId) {\n\n\n    return SpinalGraphService.removeChild(fromStateId, eventId, this\n        .EVENT_STATE_TO_EVENT_RELATION, SPINAL_RELATION_PTR_LST_TYPE)\n      .then(removed => {\n        if (removed) {\n          return SpinalGraphService.addChildInContext(toStateId, eventId,\n              contextId,\n              this.EVENT_STATE_TO_EVENT_RELATION,\n              SPINAL_RELATION_PTR_LST_TYPE)\n            .then(res => {\n              if (typeof res !== \"undefined\") {\n                let EventNode = SpinalGraphService.getRealNode(eventId);\n                let newState = SpinalGraphService.getInfo(toStateId).state\n                  .get();\n\n\n                EventNode.info.state.set(newState);\n                EventNode.info.stateId.set(toStateId);\n              }\n\n            })\n        } else {\n          return Promise.resolve(false);\n        }\n      })\n\n\n  }\n\n  ////////////////////////////////////////////////////////////////////////\n  //                        GET INFORMATION                             //\n  ////////////////////////////////////////////////////////////////////////\n\n  getVisitGroups(visitType) {\n    let contexts = SpinalGraphService.getContextWithType(visitType);\n    if (contexts.length === 0) return [];\n\n    let contextId = contexts[0].info.id.get();\n\n    return SpinalGraphService.getChildren(\n      contextId,\n      this.VISIT_TYPE_TO_GROUP_RELATION\n    ).then(res => {\n      return res.map(el => el.get());\n    });\n  }\n\n\n  getGroupEventStates(contextId, groupId) {\n    let promises = [];\n\n    for (const key in this.EVENT_STATES) {\n      promises.push(\n        this.getEventStateNode(\n          contextId,\n          groupId,\n          this.EVENT_STATES[key].type\n        )\n      );\n    }\n\n    return Promise.all(promises);\n  }\n\n  getGroupEvents(\n    groupId,\n    VISIT_TYPES = [\n      this.MAINTENANCE_VISIT,\n      this.REGULATORY_VISIT,\n      this.SECURITY_VISIT,\n      this.DIAGNOSTIC_VISIT\n    ]\n  ) {\n    if (!Array.isArray(VISIT_TYPES)) VISIT_TYPES = [VISIT_TYPES];\n\n    return VISIT_TYPES.map(visitType => {\n      let visit = this.VISITS.find(el => {\n        return el.type === visitType;\n      });\n\n      let context = SpinalGraphService.getContext(visit.name);\n\n      if (typeof context !== \"undefined\") {\n        let contextId = context.info.id.get();\n\n        return this.getGroupEventStates(contextId, groupId).then(\n          values => {\n            let prom = values.map(async eventType => {\n              let res = eventType.get();\n\n              res[\"visit_type\"] = visitType;\n\n              let events = await SpinalGraphService\n                .getChildren(\n                  res.id, [\n                    this.EVENT_STATE_TO_EVENT_RELATION\n                  ]);\n\n              res[\"events\"] = events.map(el => {\n                return el.get();\n              });\n\n              return res;\n            });\n\n            return Promise.all(prom).then(allEvents => {\n              let values = {};\n\n              allEvents.forEach(val => {\n                values[val.state] = val.events;\n              });\n\n              return {\n                [visitType]: values\n              };\n            });\n          });\n      }\n    });\n  }\n\n  getEventTasks(eventId) {\n    return SpinalGraphService.getChildren(eventId, [this\n        .EVENT_TO_TASK_RELATION\n      ])\n      .then(children => {\n        return children.map(el => el.get())\n      })\n  }\n\n  ////////////////////////////////////////////////////////////////////////\n  //                        Comment Manager                             //\n  ////////////////////////////////////////////////////////////////////////\n\n  addComment(taskId, userId, message) {\n    if (message && message.trim().length > 0 && userId) {\n      let commentNodeId = SpinalGraphService.createNode({\n        userId: userId,\n        message: message,\n        taskId: taskId,\n        date: Date.now()\n      });\n\n      if (commentNodeId) {\n        return SpinalGraphService.addChild(taskId, commentNodeId, this\n          .TASK_TO_COMMENTS_RELATION,\n          SPINAL_RELATION_PTR_LST_TYPE);\n      }\n\n    } else {\n      return Promise.reject(false);\n    }\n  }\n\n  getTasksComments(taskId) {\n    return SpinalGraphService.getChildren(taskId, [this\n      .TASK_TO_COMMENTS_RELATION\n    ]).then(children => {\n      return children.map(el => el.get());\n    })\n  }\n\n}\n\nlet spinalVisitService = new SpinalVisitService();\n\nexport default spinalVisitService;"]}},"error":null,"hash":"71cbce927623f586ea9d64d884107a48","cacheData":{"env":{}}}